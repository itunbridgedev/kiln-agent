generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Studio {
  id        Int      @id @default(autoincrement())
  name      String
  subdomain String   @unique
  domain    String? // Optional custom domain
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Stripe Connect integration
  stripeAccountId     String?   @unique // Stripe Connect account ID
  stripeAccountStatus String?   @default("not_started") // not_started, pending, complete, rejected
  stripeOnboardedAt   DateTime? // When onboarding was completed
  stripeDetailsSubmitted Boolean @default(false) // Whether they've submitted all required details
  stripeChargesEnabled   Boolean @default(false) // Whether they can accept payments
  stripePayoutsEnabled   Boolean @default(false) // Whether they can receive payouts

  // Platform fee configuration (null = use global default)
  platformFeePercentage Decimal? @db.Decimal(5, 4)

  customers     Customer[]
  categories    ProductCategory[]
  classes       Class[]
  teachingRoles TeachingRole[]
  resources     StudioResource[]
  noShowPolicies NoShowPolicy[]
  customerSuspensions CustomerSuspension[]
  memberships            Membership[]
  membershipSubscriptions MembershipSubscription[]
  openStudioBookings     OpenStudioBooking[]
}

model Customer {
  id            Int            @id @default(autoincrement())
  studioId      Int
  studio        Studio         @relation(fields: [studioId], references: [id], onDelete: Cascade)
  name          String
  email         String
  phone         String?
  picture       String?
  passwordHash  String? // For email/password auth
  passwordResetToken String? // Token for password reset requests
  passwordResetExpires DateTime? // Expiration time for reset token
  agreedToTerms   Boolean        @default(false)
  agreedToSms     Boolean        @default(false)
  isPlatformAdmin Boolean        @default(false)
  createdAt       DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  roles         CustomerRole[]
  accounts      Account[]
  sessions      Session[]

  // Class management
  classEnrollments     ClassEnrollment[]
  classStepEnrollments ClassStepEnrollment[]
  classAttendances     ClassAttendance[]
  staffTeachingRoles   StaffTeachingRole[]
  sessionInstructor    ClassSessionInstructor[]
  sessionAssistant     ClassSessionAssistant[]
  calendarFeed         StaffCalendarFeed?

  // Customer registrations
  registrations   ClassRegistration[]
  waitlistEntries ClassWaitlist[]

  // Reservation system
  reservedBy          SessionReservation[] @relation("ReservedBy")
  checkedInBy         SessionReservation[] @relation("CheckedInBy")
  cancelledBy         SessionReservation[] @relation("CancelledBy")
  reservationHistory  ReservationHistory[]
  suspensions         CustomerSuspension[]
  suspensionsLifted   CustomerSuspension[] @relation("LiftedBy")
  membershipSubscriptions MembershipSubscription[]

  @@unique([studioId, email])
  @@index([studioId])
}

model Role {
  id        Int            @id @default(autoincrement())
  name      String         @unique
  customers CustomerRole[]
}

model CustomerRole {
  id         Int      @id @default(autoincrement())
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId Int
  role       Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  roleId     Int

  @@unique([customerId, roleId])
}

model Account {
  id                Int       @id @default(autoincrement())
  customer          Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId        Int
  provider          String // "google", "email", etc.
  providerAccountId String // Google user ID
  accessToken       String?   @db.Text
  refreshToken      String?   @db.Text
  expiresAt         DateTime?
  tokenType         String?
  scope             String?
  idToken           String?   @db.Text
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@unique([provider, providerAccountId])
}

model Session {
  id           Int      @id @default(autoincrement())
  sessionToken String   @unique
  customer     Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId   Int
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model ProductCategory {
  id               Int               @id @default(autoincrement())
  studioId         Int
  studio           Studio            @relation(fields: [studioId], references: [id], onDelete: Cascade)
  name             String
  description      String?
  displayOrder     Int               @default(0)
  isActive         Boolean           @default(true)
  isSystemCategory Boolean           @default(false) // System categories can't be deleted
  featureModule    String? // e.g., "class-management", "firing-workflow"
  parentCategoryId Int? // For subcategories
  parentCategory   ProductCategory?  @relation("CategoryHierarchy", fields: [parentCategoryId], references: [id], onDelete: Cascade)
  subcategories    ProductCategory[] @relation("CategoryHierarchy")
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  classes          Class[]

  @@unique([studioId, name])
  @@index([studioId])
  @@index([parentCategoryId])
}

// Classes Feature Module
model Class {
  id               Int             @id @default(autoincrement())
  studioId         Int
  studio           Studio          @relation(fields: [studioId], references: [id], onDelete: Cascade)
  categoryId       Int // Link to ProductCategory (can be main category or subcategory)
  category         ProductCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  teachingRoleId   Int? // Link to TeachingRole instead of specific instructor
  teachingRole     TeachingRole?   @relation(fields: [teachingRoleId], references: [id], onDelete: SetNull)
  name             String
  description      String?
  classType        String          @default("multi-session") // "multi-session", "single-session", "series", "multi-step", "open-studio"
  durationWeeks    Int? // Number of weeks for multi-session classes (null for single-session)
  durationHours    Decimal?        @db.Decimal(4, 2) // Duration in hours for single-session classes (null for multi-session)
  isRecurring      Boolean         @default(false) // True for series classes that renew weekly
  requiresSequence Boolean         @default(false) // True for multi-step classes where order matters
  maxStudents      Int // Maximum capacity
  price            Decimal         @db.Decimal(10, 2)
  skillLevel       String? // "Beginner", "Intermediate", "Advanced", "All Levels"
  imageUrl         String?
  isActive         Boolean         @default(true)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  schedules            ClassSchedule[]
  schedulePatterns     ClassSchedulePattern[]
  steps                ClassStep[] // For multi-step classes
  sessions             ClassSession[] // Direct sessions for series classes
  registrations        ClassRegistration[]
  waitlistEntries      ClassWaitlist[]
  resourceRequirements ClassResourceRequirement[]
  noShowPolicies       NoShowPolicy[]

  @@index([studioId])
  @@index([categoryId])
  @@index([teachingRoleId])
  @@index([classType])
}

// For multi-step classes (e.g., Mug Making Part 1, Part 2, Part 3)
model ClassStep {
  id                 Int      @id @default(autoincrement())
  studioId           Int
  classId            Int
  class              Class    @relation(fields: [classId], references: [id], onDelete: Cascade)
  stepNumber         Int // 1, 2, 3, etc.
  name               String // "Part 1 - Basic Mug Shape"
  description        String?
  durationHours      Decimal  @db.Decimal(4, 2)
  learningObjectives String? // What students will learn
  requiresSequence   Boolean  @default(false) // Must complete previous steps first
  allowMakeup        Boolean  @default(false) // Can be used for makeup sessions
  isActive           Boolean  @default(true)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  schedules        ClassSchedule[]
  schedulePatterns ClassSchedulePattern[]
  sessions         ClassSession[]
  enrollments      ClassStepEnrollment[]

  @@unique([classId, stepNumber])
  @@index([studioId])
  @@index([classId])
}

model ClassSchedule {
  id            Int        @id @default(autoincrement())
  studioId      Int
  classId       Int
  class         Class      @relation(fields: [classId], references: [id], onDelete: Cascade)
  classStepId   Int? // For multi-step classes, which step this schedule is for
  classStep     ClassStep? @relation(fields: [classStepId], references: [id], onDelete: Cascade)
  startDate     DateTime // First session date (or date of single-session class)
  endDate       DateTime? // Last session date (null for single-session/series classes)
  dayOfWeek     Int? // 0=Sunday, 1=Monday, etc. (null for single-session)
  startTime     String // Format: "HH:MM" (24-hour)
  endTime       String // Format: "HH:MM" (24-hour)
  enrolledCount Int        @default(0)
  status        String     @default("open") // "open", "full", "in-progress", "completed", "cancelled"
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  sessions        ClassSession[]
  enrollments     ClassEnrollment[]
  registrations   ClassRegistration[]
  waitlistEntries ClassWaitlist[]

  @@index([studioId])
  @@index([classId])
  @@index([classStepId])
  @@index([startDate])
}

// Recurring schedule patterns using RRULE standard
model ClassSchedulePattern {
  id          Int        @id @default(autoincrement())
  studioId    Int
  classId     Int
  class       Class      @relation(fields: [classId], references: [id], onDelete: Cascade)
  classStepId Int? // For multi-step classes
  classStep   ClassStep? @relation(fields: [classStepId], references: [id], onDelete: Cascade)

  // Pattern definition using RRULE (RFC 5545 iCalendar format)
  recurrenceRule String // RRULE format: "FREQ=WEEKLY;BYDAY=TU;COUNT=8"
  startDate      DateTime // Pattern starts on this date
  endDate        DateTime? // Pattern ends on this date (or COUNT in RRULE)

  // Time slots
  startTime     String  // Format: "HH:MM" (24-hour)
  endTime       String? // Format: "HH:MM" - For series schedules, time when last session starts
  durationHours Decimal @db.Decimal(4, 2) // Duration in hours (e.g., 2.5)

  // Capacity
  maxStudents Int // Default max students per session
  location    String? // Default location for sessions

  // Default staff assignments
  defaultInstructorId Int? // Default instructor for generated sessions
  defaultAssistantId  Int? // Default assistant for generated sessions

  // Status
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions ClassSession[]

  @@index([studioId])
  @@index([classId])
  @@index([classStepId])
  @@index([startDate])
}

model ClassSession {
  id                Int                   @id @default(autoincrement())
  studioId          Int
  scheduleId        Int? // Null for series classes without pre-defined schedules
  schedule          ClassSchedule?        @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  schedulePatternId Int? // Link to pattern (null for one-off sessions)
  schedulePattern   ClassSchedulePattern? @relation(fields: [schedulePatternId], references: [id], onDelete: SetNull)
  classId           Int // Direct link to class for series tracking
  class             Class                 @relation(fields: [classId], references: [id], onDelete: Cascade)
  classStepId       Int? // For multi-step classes
  classStep         ClassStep?            @relation(fields: [classStepId], references: [id], onDelete: Cascade)
  sessionNumber     Int? // Week 1, Week 2, etc. (null for series classes)
  sessionDate       DateTime // Specific date for this session
  startTime         String // Format: "HH:MM" (24-hour)
  endTime           String // Format: "HH:MM" (24-hour)
  maxStudents       Int? // Override pattern default if needed
  currentEnrollment Int                   @default(0)
  location          String? // Override pattern default if needed
  topic             String? // Optional topic for the session
  notes             String? // Instructor notes
  isCancelled       Boolean               @default(false)
  status            String                @default("scheduled") // "scheduled", "in-progress", "completed", "cancelled"

  // Calendar sync metadata
  externalEventId    String? // Google/Outlook event ID
  calendarSyncStatus String? // 'synced', 'pending', 'error'
  lastSyncedAt       DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Resource hold settings for capacity reservation
  reserveFullCapacity  Boolean @default(false)
  resourceReleaseHours Int?

  attendances          ClassAttendance[]
  instructors          ClassSessionInstructor[]
  assistants           ClassSessionAssistant[]
  registrationSessions RegistrationSession[]
  reservations         SessionReservation[]
  waitlistEntries      ClassWaitlist[]
  resourceAllocations  SessionResourceAllocation[]
  openStudioBookings   OpenStudioBooking[]

  @@index([studioId])
  @@index([scheduleId])
  @@index([schedulePatternId])
  @@index([classId])
  @@index([classStepId])
  @@index([sessionDate])
}

// Track instructors assigned to a session
model ClassSessionInstructor {
  id         Int           @id @default(autoincrement())
  sessionId  Int
  session    ClassSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  customerId Int // Staff member assigned as instructor
  customer   Customer      @relation(fields: [customerId], references: [id], onDelete: Cascade)
  roleId     Int? // Optional: specific teaching role for this session
  role       TeachingRole? @relation(fields: [roleId], references: [id], onDelete: SetNull)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  @@unique([sessionId, customerId])
  @@index([sessionId])
  @@index([customerId])
  @@index([roleId])
}

// Track assistants assigned to a session
model ClassSessionAssistant {
  id         Int           @id @default(autoincrement())
  sessionId  Int
  session    ClassSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  customerId Int // Staff member assigned as assistant
  customer   Customer      @relation(fields: [customerId], references: [id], onDelete: Cascade)
  roleId     Int? // Optional: specific teaching role for this session
  role       TeachingRole? @relation(fields: [roleId], references: [id], onDelete: SetNull)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  @@unique([sessionId, customerId])
  @@index([sessionId])
  @@index([customerId])
  @@index([roleId])
}

// Calendar feed subscriptions for staff members
model StaffCalendarFeed {
  id          Int      @id @default(autoincrement())
  customerId  Int      @unique // One feed per staff member
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  secureToken String   @unique @default(uuid()) // Secure token for feed URL
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([secureToken])
}

// Track student enrollments in a class schedule
model ClassEnrollment {
  id         Int           @id @default(autoincrement())
  studioId   Int
  scheduleId Int
  schedule   ClassSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  customerId Int
  customer   Customer      @relation(fields: [customerId], references: [id], onDelete: Cascade)
  enrolledAt DateTime      @default(now())
  status     String        @default("active") // "active", "completed", "dropped", "waitlist"

  @@unique([scheduleId, customerId])
  @@index([studioId])
  @@index([scheduleId])
  @@index([customerId])
}

// Track which steps a student has completed in multi-step classes
model ClassStepEnrollment {
  id          Int       @id @default(autoincrement())
  studioId    Int
  classStepId Int
  classStep   ClassStep @relation(fields: [classStepId], references: [id], onDelete: Cascade)
  customerId  Int
  customer    Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  completedAt DateTime? // Null if not yet completed
  status      String    @default("in-progress") // "in-progress", "completed", "skipped"

  @@unique([classStepId, customerId])
  @@index([studioId])
  @@index([classStepId])
  @@index([customerId])
}

// Track attendance for individual sessions (especially for series classes)
model ClassAttendance {
  id         Int          @id @default(autoincrement())
  studioId   Int
  sessionId  Int
  session    ClassSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  customerId Int
  customer   Customer     @relation(fields: [customerId], references: [id], onDelete: Cascade)
  attendedAt DateTime     @default(now())
  notes      String? // Optional attendance notes

  @@unique([sessionId, customerId])
  @@index([studioId])
  @@index([sessionId])
  @@index([customerId])
}

// Teaching Roles & Staff Management
model TeachingRole {
  id          Int      @id @default(autoincrement())
  studioId    Int
  studio      Studio   @relation(fields: [studioId], references: [id], onDelete: Cascade)
  name        String // "Basic Teacher", "Intermediate Teacher", "Glazing Specialist"
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  staffRoles         StaffTeachingRole[]
  classes            Class[]
  sessionInstructors ClassSessionInstructor[]
  sessionAssistants  ClassSessionAssistant[]

  @@unique([studioId, name])
  @@index([studioId])
}

model StaffTeachingRole {
  id          Int          @id @default(autoincrement())
  customerId  Int // References Customer (staff member)
  customer    Customer     @relation(fields: [customerId], references: [id], onDelete: Cascade)
  roleId      Int
  role        TeachingRole @relation(fields: [roleId], references: [id], onDelete: Cascade)
  certifiedAt DateTime?
  notes       String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@unique([customerId, roleId])
  @@index([customerId])
  @@index([roleId])
}

// Customer Registration & Enrollment
enum RegistrationType {
  SINGLE_SESSION // Register for one specific session
  FULL_SCHEDULE // Register for all sessions in a schedule
  DROP_IN // Drop-in registration for series classes
}

enum RegistrationStatus {
  PENDING // Payment pending or admin approval needed
  CONFIRMED // Confirmed and paid
  WAITLISTED // Added to waitlist (full class)
  CANCELLED // Cancelled by customer
  REFUNDED // Cancelled and refunded
  NO_SHOW // Customer didn't attend
}

enum PaymentStatus {
  PENDING // Payment not yet processed
  COMPLETED // Payment successful
  FAILED // Payment failed
  REFUNDED // Payment refunded
  PARTIAL_REFUND // Partial refund issued
}

enum PassType {
  UNLIMITED_SERIES // Attend any session within date range
  PUNCH_PASS // Limited number of sessions (e.g., 8-session pass)
  FULL_COURSE // Must attend all sessions in sequence
}

enum ReservationStatus {
  PENDING // Reserved but not attended
  CHECKED_IN // Customer checked in
  ATTENDED // Confirmed attendance
  NO_SHOW // Didn't show for reservation
  CANCELLED // Cancelled by customer
  AUTO_CANCELLED // System cancelled due to previous absence
}

model ClassRegistration {
  id         Int      @id @default(autoincrement())
  studioId   Int
  customerId Int?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // Guest booking information (for non-authenticated bookings)
  guestName  String?
  guestEmail String?
  guestPhone String?

  // What they're registering for
  scheduleId Int? // For FULL_SCHEDULE type
  schedule   ClassSchedule? @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  classId    Int // Always link to the class
  class      Class          @relation(fields: [classId], references: [id], onDelete: Cascade)

  // Registration details
  registrationType   RegistrationType
  registrationStatus RegistrationStatus @default(PENDING)
  guestCount         Int                @default(1) // Number of people attending
  registeredAt       DateTime           @default(now())
  confirmedAt        DateTime? // When status changed to CONFIRMED
  cancelledAt        DateTime? // When cancelled
  cancellationReason String?

  // Flexible reservation fields
  passType                      PassType? @default(FULL_COURSE)
  sessionsIncluded              Int? // null = unlimited, number = punch pass limit
  sessionsRemaining             Int? // Tracks remaining punches
  sessionsAttended              Int       @default(0) // Total sessions attended
  maxAdvanceReservations        Int       @default(3) // Max sessions that can be reserved in advance
  requiresSequentialAttendance  Boolean   @default(false) // Must complete in order (multi-step series)
  absenceGracePeriodHours       Int       @default(24) // Hours before auto-canceling future reservations
  validFrom                     DateTime? // Pass start date
  validUntil                    DateTime? // Pass expiration date

  // Payment information
  amountPaid      Decimal       @db.Decimal(10, 2)
  paymentStatus   PaymentStatus @default(PENDING)
  paymentIntentId String? // Stripe PaymentIntent ID
  stripeChargeId  String? // Stripe Charge ID
  stripeTransferId String? // Stripe Transfer ID (for Connect transfers to studio)
  stripeFeeAmount Decimal? @db.Decimal(10, 2) // Platform fee taken
  studioPayoutAmount Decimal? @db.Decimal(10, 2) // Amount transferred to studio
  refundAmount    Decimal?      @db.Decimal(10, 2)
  refundedAt      DateTime?

  // Notes
  customerNotes String? // Notes from customer during registration
  adminNotes    String? // Internal notes from staff

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  sessions            RegistrationSession[]
  reservations        SessionReservation[]
  resourceAllocations SessionResourceAllocation[]

  @@index([studioId])
  @@index([customerId])
  @@index([scheduleId])
  @@index([classId])
  @@index([registrationStatus])
  @@index([paymentStatus])
  @@index([passType])
  @@index([validFrom])
  @@index([validUntil])
}

// Junction table linking registrations to specific sessions
model RegistrationSession {
  id             Int               @id @default(autoincrement())
  registrationId Int
  registration   ClassRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  sessionId      Int
  session        ClassSession      @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Track attendance for this specific session
  attended   Boolean   @default(false)
  attendedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([registrationId, sessionId])
  @@index([registrationId])
  @@index([sessionId])
}

// Enhanced reservation system for flexible class booking
model SessionReservation {
  id             Int               @id @default(autoincrement())
  studioId       Int
  registrationId Int
  registration   ClassRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  sessionId      Int
  session        ClassSession      @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // Reservation status
  reservationStatus ReservationStatus @default(PENDING)

  // Reservation lifecycle
  reservedAt DateTime  @default(now())
  reservedBy Int? // Customer who made reservation
  reservedByCustomer Customer? @relation("ReservedBy", fields: [reservedBy], references: [id], onDelete: SetNull)

  // Check-in tracking
  checkedInAt     DateTime?
  checkedInBy     Int? // Customer or staff who checked in
  checkedInByCustomer Customer? @relation("CheckedInBy", fields: [checkedInBy], references: [id], onDelete: SetNull)
  checkedInMethod String? // 'SELF', 'STAFF', 'AUTO'

  // Attendance tracking
  attendedAt       DateTime?
  noShowDetectedAt DateTime?
  autoCancelledAt  DateTime?

  // Cancellation
  cancelledAt       DateTime?
  cancelledBy       Int? // Customer who cancelled
  cancelledByCustomer Customer? @relation("CancelledBy", fields: [cancelledBy], references: [id], onDelete: SetNull)
  cancellationReason String?

  // Notes
  staffNotes    String?
  customerNotes String?

  // Punch tracking
  punchUsed       Boolean   @default(false)
  punchDeductedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  history ReservationHistory[]

  @@unique([registrationId, sessionId])
  @@index([studioId])
  @@index([registrationId])
  @@index([sessionId])
  @@index([reservationStatus])
  @@index([registrationId, reservationStatus])
  @@index([sessionId, reservationStatus])
  @@index([reservedAt])
  @@index([checkedInAt])
}

// Audit log for reservation changes
model ReservationHistory {
  id            Int                @id @default(autoincrement())
  reservationId Int
  reservation   SessionReservation @relation(fields: [reservationId], references: [id], onDelete: Cascade)

  action          String // 'CREATED', 'CHECKED_IN', 'CANCELLED', 'NO_SHOW', 'AUTO_CANCELLED'
  performedBy     Int? // Customer who performed action
  performedByCustomer Customer? @relation(fields: [performedBy], references: [id], onDelete: SetNull)
  performedByRole String? // 'CUSTOMER', 'STAFF', 'SYSTEM'
  previousStatus  ReservationStatus?
  newStatus       ReservationStatus?
  reason          String?
  metadata        Json? // Additional context

  timestamp DateTime @default(now())

  @@index([reservationId])
  @@index([timestamp])
}

// Configurable no-show policies per studio/class
model NoShowPolicy {
  id       Int    @id @default(autoincrement())
  studioId Int
  studio   Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)
  classId  Int? // null means studio-wide default
  class    Class? @relation(fields: [classId], references: [id], onDelete: Cascade)

  // Policy settings
  gracePeriodHours            Int     @default(24) // Hours after no-show before auto-cancel
  maxNoShowsBeforeSuspension  Int?    @default(3)
  suspensionDurationDays      Int?    @default(7)
  deductPunchOnNoShow         Boolean @default(true)
  allowSameDayRebooking       Boolean @default(false)
  sendNoShowNotification      Boolean @default(true)
  sendAutoCancelNotification  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([studioId, classId])
  @@index([studioId])
  @@index([classId])
}

// Track suspended customers due to no-shows
model CustomerSuspension {
  id         Int      @id @default(autoincrement())
  studioId   Int
  studio     Studio   @relation(fields: [studioId], references: [id], onDelete: Cascade)
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  reason       String
  noShowCount  Int      @default(0)
  suspendedAt  DateTime @default(now())
  suspendedUntil DateTime

  liftedAt     DateTime?
  liftedBy     Int? // Staff member who lifted suspension
  liftedByStaff Customer? @relation("LiftedBy", fields: [liftedBy], references: [id], onDelete: SetNull)
  liftedReason String?
  isActive     Boolean   @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([studioId])
  @@index([customerId])
  @@index([isActive])
  @@index([suspendedUntil])
}

// Waitlist for fully booked classes
model ClassWaitlist {
  id         Int      @id @default(autoincrement())
  studioId   Int
  customerId Int
  customer   Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  // What they're waiting for
  scheduleId Int? // Specific schedule
  schedule   ClassSchedule? @relation(fields: [scheduleId], references: [id], onDelete: Cascade)
  sessionId  Int? // Specific session for DROP_IN
  session    ClassSession?  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  classId    Int // Always link to the class
  class      Class          @relation(fields: [classId], references: [id], onDelete: Cascade)

  // Waitlist management
  position                Int // Position in line
  joinedAt                DateTime  @default(now())
  notifiedAt              DateTime? // When customer was notified of opening
  expiresAt               DateTime? // Notification expires after X hours
  convertedToRegistration Boolean   @default(false)
  registrationId          Int? // If they registered after notification
  removedAt               DateTime? // If removed from waitlist
  removalReason           String? // "registered", "expired", "cancelled"

  customerNotes String? // Notes from customer

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([studioId])
  @@index([customerId])
  @@index([scheduleId])
  @@index([sessionId])
  @@index([classId])
  @@index([position])
}

// Studio Resources (wheels, kilns, painting stations, etc.)
model StudioResource {
  id          Int      @id @default(autoincrement())
  studioId    Int
  name        String // "Pottery Wheel", "Painting Station", "Glazing Station", etc.
  description String?
  quantity    Int // Total number available
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  classResourceRequirements  ClassResourceRequirement[]
  sessionResourceAllocations SessionResourceAllocation[]
  openStudioBookings         OpenStudioBooking[]
  studio                     Studio                      @relation(fields: [studioId], references: [id])

  @@unique([studioId, name])
  @@index([studioId])
}

// Resources required for a class type
model ClassResourceRequirement {
  id                 Int            @id @default(autoincrement())
  classId            Int
  class              Class          @relation(fields: [classId], references: [id], onDelete: Cascade)
  resourceId         Int
  resource           StudioResource @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  quantityPerStudent Int            @default(1) // How many of this resource each student needs
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  @@unique([classId, resourceId])
  @@index([classId])
  @@index([resourceId])
}

// Track resource allocation for each registration
model SessionResourceAllocation {
  id             Int               @id @default(autoincrement())
  registrationId Int
  registration   ClassRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  sessionId      Int
  session        ClassSession      @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  resourceId     Int
  resource       StudioResource    @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  quantity       Int // Number of resources allocated (based on guest count)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  @@index([registrationId])
  @@index([sessionId])
  @@index([resourceId])
  @@index([sessionId, resourceId]) // For availability checks
}

// =============================================
// Membership System
// =============================================

enum BillingPeriod {
  MONTHLY
  QUARTERLY
  ANNUAL
}

enum SubscriptionStatus {
  ACTIVE
  PAUSED
  CANCELLED
  PAST_DUE
  EXPIRED
}

enum OpenStudioBookingStatus {
  RESERVED
  CHECKED_IN
  COMPLETED
  CANCELLED
  NO_SHOW
}

// Membership tier definition (e.g., Basic, Premium, Unlimited)
model Membership {
  id              Int       @id @default(autoincrement())
  studioId        Int
  studio          Studio    @relation(fields: [studioId], references: [id])
  name            String
  description     String?
  price           Decimal   @db.Decimal(10, 2)
  billingPeriod   BillingPeriod
  benefits        Json      // Structured benefits JSON
  isActive        Boolean   @default(true)
  displayOrder    Int       @default(0)
  stripeProductId String?
  stripePriceId   String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  subscriptions   MembershipSubscription[]

  @@unique([studioId, name])
  @@index([studioId])
}

// Customer's active membership subscription
model MembershipSubscription {
  id                    Int                @id @default(autoincrement())
  studioId              Int
  studio                Studio             @relation(fields: [studioId], references: [id])
  customerId            Int
  customer              Customer           @relation(fields: [customerId], references: [id])
  membershipId          Int
  membership            Membership         @relation(fields: [membershipId], references: [id])

  status                SubscriptionStatus
  stripeSubscriptionId  String?            @unique
  stripeCustomerId      String?

  startDate             DateTime
  currentPeriodStart    DateTime
  currentPeriodEnd      DateTime
  cancelledAt           DateTime?
  cancellationReason    String?
  pausedAt              DateTime?

  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt

  openStudioBookings    OpenStudioBooking[]

  @@unique([studioId, customerId, membershipId])
  @@index([studioId, status])
}

// Open Studio time-block booking on a specific resource
model OpenStudioBooking {
  id               Int                    @id @default(autoincrement())
  studioId         Int
  studio           Studio                 @relation(fields: [studioId], references: [id])
  subscriptionId   Int
  subscription     MembershipSubscription @relation(fields: [subscriptionId], references: [id])
  sessionId        Int
  session          ClassSession           @relation(fields: [sessionId], references: [id])
  resourceId       Int
  resource         StudioResource         @relation(fields: [resourceId], references: [id])

  startTime        String                 // "14:00" â€” within the session window
  endTime          String                 // "16:00"

  status           OpenStudioBookingStatus
  isWalkIn         Boolean                @default(false)

  reservedAt       DateTime               @default(now())
  checkedInAt      DateTime?
  completedAt      DateTime?
  cancelledAt      DateTime?

  @@unique([sessionId, resourceId, startTime])
  @@index([studioId, sessionId])
}
